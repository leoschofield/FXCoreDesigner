cpy_cs    acc32, in0
; first check for a forced playback state where user recorded longer than
; the 32K samples, special state as we need to ignore certain things
andi     status, 0x0002           ; are we in a forced playback state?
jz       acc32, normal            ; no so either a record or playback
andi     status, 0x0001           ; first time in forced playback?
jz       acc32, force_more        ; if not then check other force issues
andi     status, 0x0002           ; change status to forced but not first time
cpy_cc   status, acc32
xor      acc32, acc32             ; clear acc32
cpy_cc   ptr, acc32               ; reset the pointer
jmp      pb                       ; jump to playback
force_more:
andi     flags, taplvl            ; get the tap button state
jz       acc32, pb                ; if == 0 jump as user is still pushing it (pin has pull-up so pressed button is a 0)
xor      acc32, acc32             ; if here user has released it, clear acc32
cpy_cc   status, acc32            ; set status to playback, do not reset ptr as that should have been done on the first pass
jmp      pb


normal:
andi     flags, taplvl            ; get the tap button state
jnz      acc32, playback          ; if != 0 jump (pin has pull-up so pressed button is a 0)
andi     status, 0x0001           ; tap button pushed (is 0), was the last state record?
jnz      acc32, record            ; yes, continue recording
xor      acc32, acc32             ; nope, so starting a new recording
cpy_cc   ptr, acc32               ; reset pointer
cpy_cc   length, acc32            ; and length count
jmp      record                   ; and record

playback:
; Playback
andi     status, 0x0001           ; was the last state record?
jz       acc32, pb                ; no, continue playback
xor      acc32, acc32             ; yes it was
cpy_cc   ptr, acc32               ; reset pointer
cpy_cc   status, acc32            ; set status to playback
pb:
rddirx   acc32, ptr               ; read from current pointer position
cpy_cs   temp, in0                ; get the dry
adds     acc32, temp              ; add them
cpy_sc   out0, acc32              ; write to output
cpy_sc   out1, acc32              ; and to other output
; read sw0
cpy_cs   acc32, switch
andi     acc32, sw0
jz       acc32, forward           ; if switch 0 is 0 then forward playback
jz       ptr, ptr_zero            ; playing back backwards, if ptr is zero we need to reset it
subs     ptr, acc32               ; since the lsb was left set in the above andi we can just subtract
cpy_cc   ptr, acc32               ; copy updated pointer
jmp      over                     ; and jump past rest
ptr_zero:
subs     length, acc32            ; pointer was zero, need to rest to end
cpy_cc   ptr, acc32               ; which was easy as the lsb was set in acc32 already
jmp      over                     ; so just subtract it from the length, save it and jump

forward:
xor      acc32, acc32             ; clear the acc32
ori      acc32, 0x0001            ; set lsb
add      ptr, acc32               ; add to current ptr
cpy_cc   ptr, acc32               ; save it
subs     ptr, length              ; ptr - length
jnz      acc32, over              ; if !=0 then not at end jump over the rest
xor      acc32, acc32             ; if 0 then load 0 into acc32
cpy_cc   ptr, acc32               ; copy to ptr
jmp      over                     ; jump to end

record:
; read input and write to delay
xor      acc32, acc32             ; set status to record
ori      acc32, 0x0001
cpy_cc   status, acc32
cpy_cs   temp, in0                ; read input 0
wrdirx   ptr, temp                ; write to delay
cpy_sc   out0, temp               ; and to out0
cpy_sc   out1, temp               ; and to out1
xor      acc32, acc32             ; clear acc32
ori      acc32, 0x0001            ; set lsb
add      ptr, acc32               ; add to current ptr
cpy_cc   ptr, acc32               ; save it
cpy_cc   length, acc32            ; and save to length
xori     length, 0x8000           ; XOR length with 0x8000
jnz      acc32, over              ; if not 0 then not at max count
ori      acc32, 0x0003            ; passed the end, forced playback
cpy_cc   status, acc32


over:
cpy_cs    acc32, samplecnt        ; Get the sample counter
andi      acc32, 0xFF             ; Mask b[7:0]
jnz       acc32, doPWM0           ;

sr        ptr, 8
cpy_cc    bright, acc32           ; save it

doPWM0:
; Performing the decrement prior to driving the LED makes sure
; that the LED can go completly off.
addi      bright, -1              ; subtract 1 from on count
cpy_cc    bright, acc32           ; Save updated "bright"
xor       acc32, acc32            ; Clear acc32 for the LED off case
jneg      bright, doLED0          ;
ori       acc32, 1                ; Set acc32[0] for the LED on case

doLED0:
set       user0|0, acc32           ; set the usr0 output per the acc32 LSB

; PWM usr1
cpy_cs    acc32, samplecnt        ; Get the sample counter
andi      acc32, 0xFF             ; Mask b[7:0]
jnz       acc32, doPWM1           ;

sr        length, 8
cpy_cc    bright2, acc32          ; save it

doPWM1:
; Performing the decrement prior to driving the LED makes sure
; that the LED can go completly off.
addi      bright2, -1             ; subtract 1 from on count
cpy_cc    bright2, acc32          ; Save updated "bright"
xor       acc32, acc32            ; Clear acc32 for the LED off case
jneg      bright2, doLED1         ;
ori       acc32, 1                ; Set acc32[0] for the LED on case

doLED1:
set       user1|0, acc32           ; set the usr0 output per the acc32 LSBcpy_cs    out0, acc32
